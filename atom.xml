<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>遊びたがりブログ</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://asobitagari.github.io/"/>
  <updated>2021-01-25T16:05:23.605Z</updated>
  <id>https://asobitagari.github.io/</id>
  
  <author>
    <name>ざきさん</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>オンライン英会話　はじめました</title>
    <link href="https://asobitagari.github.io/2021/01/25/started-learning-online-english-conversation/"/>
    <id>https://asobitagari.github.io/2021/01/25/started-learning-online-english-conversation/</id>
    <published>2021-01-25T02:43:57.000Z</published>
    <updated>2021-01-25T16:05:23.605Z</updated>
    
    <content type="html"><![CDATA[<p>2021/01/20 より、スパトレというオンライン英会話を受け始めました。</p><p>調べた限りで、毎日レッスンが可能なプランがあるオンライン英会話のサービスの中で最安値（税抜き月額¥2,980）。上位プランとして無制限のプランもあり、+2,000円ほどの料金設定になっています。7日間のお試し期間があり、どちらのプランも選択できたので無制限プランを選択してみました。<br>他のオンライン英会話サービスと比べて面白いと感じたところは、フリートークのレッスンが一切なく、基本的には教材ベースでレッスンが進んでいく点でした。教材に関しては幾つかのオリジナル教材と指定の市販教本から選択でき、指定の市販教本は自前で用意する必要があります。ただ、オリジナル教材（無料）は潤沢といえるほどでもなく、また選べる市販教本も豊富といえるほどでもないなと感じました。もちろん全部買おうとしたらかなりの金額になるのは間違いないくらいには選べました。それに、そんなに買わなければならなくなるまえにはしゃべれるようになりたい、むしろオリジナル教材だけでしゃべれるようになりたいです。</p><p>初回は実力テストを行う必要があるので、テストしてもらいました。</p><p>いつかは英語を喋ったり、英語の技術情報がスラスラと読めるようになればなと、自分で買っていたテキスト「<a href="https://amzn.to/2M4Ea0e" title="速読速聴・英単語 Basic2400">速読速聴・英単語 Basic2400</a>」を読むようなことは、思い出すたびにしてきましたが結果は散々でした。</p><p><img src="/2021/01/25/started-learning-online-english-conversation/2021-01-25-161359.png" alt="実力テストグラフ" title="実力テストグラフ"></p><p>チャートグラフの欠点を大いに実感できるパラメータに・・・。左と真下がどうやら0のようで、値が詰まりまくってて何の項目だったかまるで分らない状態です。公式のHPにある例のグラフはちゃんと読めるようになっていたので、それを参考に読み解くことができたのが幸いでした。それにしてもこんなに小さなグラフになるとは・・・。</p><h3 id="CEFR"><a href="#CEFR" class="headerlink" title="CEFR"></a>CEFR</h3><p>** A1 ** : 最下層かい！中一レベル（今は違うのかな）でした。先ほどの書籍は中学レベルからのおさらいなので奇しくもレベルに合ったものを読んでいた結果に・・・。</p><h3 id="言語認識-dictation"><a href="#言語認識-dictation" class="headerlink" title="言語認識 (dictation)"></a>言語認識 (dictation)</h3><p>2/10 : 初級学習から3か月以内で今回のテストの内容がすべてリスニングできるようになるので安心してくださいとのコメントが。ほんかよ・・・。全くわからなかったぜ・・・。</p><h3 id="意味理解-listening"><a href="#意味理解-listening" class="headerlink" title="意味理解 (listening)"></a>意味理解 (listening)</h3><p>0/10 : 0ってなんなの？意味わかってないけど、言語の認識はしてたってことか？なんにせよ、これが0だと英（会話）には絶対にならんよね。</p><h3 id="データベース-vocabulary"><a href="#データベース-vocabulary" class="headerlink" title="データベース (vocabulary)"></a>データベース (vocabulary)</h3><p>2/10 : 意味は理解できないけど 2/10 くらいは単語把握してるっぽい・・・。</p><h3 id="組み立て-speaking"><a href="#組み立て-speaking" class="headerlink" title="組み立て (speaking)"></a>組み立て (speaking)</h3><p>5/10 : こわっ！これでしゃべりがここまでできてるってどういうことなんだ・・・。理系志向だと辻褄ってものがあってない感満載なんだが・・・。</p><h3 id="インタラクション-interaction"><a href="#インタラクション-interaction" class="headerlink" title="インタラクション (interaction)"></a>インタラクション (interaction)</h3><p>4/10 : 簡単な単語を使って作られた1文程度の文章なら理解できる・・・だと？</p><h3 id="文法-grammar"><a href="#文法-grammar" class="headerlink" title="文法 (grammar)"></a>文法 (grammar)</h3><p>0/10 : 日本人は文法はマニアなくらい知ってるよね？っていう日本の英語教育を受けてきたとは到底思えないスコアだ・・・。</p><h3 id="音声化-pronunciation"><a href="#音声化-pronunciation" class="headerlink" title="音声化 (pronunciation)"></a>音声化 (pronunciation)</h3><p>3/10 : よく知ってるフレーズに関しては流暢だけど、そうでないと途端日本語じみてきますね。みたいなニュアンスが書かれてる。</p><p>チャートには Lexile指数というものがあって、解説にはない。<br>また解説にはあるがチャートには CEFRはない。内容的にはイコールではないはずだがどうなんだろう。</p><p>この診断結果には、各項目の解説の終わりにおすすめの教本が紹介されている。市販教本が多く紹介されているが、自分の結果とマッチさせるとたまたまこうなったのか、いつも市販教本が大目に紹介されるかはよくわからないが、オリジナル教材をざっと見た限り、文法系や単語系はそもそもよういしていなさそうではあった。まあ、このあたりは教本は紹介されているけど、同程度の本をお持ちなら自分で見直してみてくださいみたいなことも書いてあるから、サービスとして重視している部分が違うってことなのだろう。</p><h2 id="レッスンの感想"><a href="#レッスンの感想" class="headerlink" title="レッスンの感想"></a>レッスンの感想</h2><p>テストを受けた翌日から、日曜を抜かして毎日レッスンを受けてみた。あまりにもテストが散々だったので、オリジナル教材の中で一つだけある超初心者向けレッスン（全10回）を受けてみている。日に1つから２つほどレッスンが進む。いまなら小学生がするような内容のレッスンだが、なかなか口から英語が出てくれない自分にはむしろぴったりに感じた。ここで見栄を張って難しそうなレッスンから始めようとしなくてよかった。</p><p>このサービスの面白い点は、各トレーニングに対して宿題がある点です。レッスンを始める前までにその教材に対してどういう学習をしてくればいいのかが記されています。”とりあえず英会話をしてみる”というスタンスが不安な方はむしろこの宿題がいい予習になってやりやすいんじゃないかと思いました。かならず復習してくださいと出ている点も、授業後にその授業内容の録画が送られてくるのですが見直す契機になってくれます。</p><p>テストを受けた直後はむちゃくちゃ委縮して続けられないんじゃないかと思いましたが、トレーニングの幅の広さと事前事後の学習の後押しなどのおかげで、超初心者コースが終わった後は何を受けようかなどと考えられるくらい楽しめています。また、その会話外の学習量がそれなりにあるため、一日何回も受けるのは初心者にはむしろ効率的ではないのかなと感じましたので、お試し期間後は通常プランに戻そうと思いました。</p><p><a href="//af.moshimo.com/af/c/click?a_id=2406885&p_id=3096&pc_id=7158&pl_id=40612&guid=ON" rel="nofollow"><img src="//image.moshimo.com/af-img/1881/000000040612.png" width="400" height="300" style="border:none;"></a><img src="//i.moshimo.com/af/i/impression?a_id=2406885&p_id=3096&pc_id=7158&pl_id=40612" width="1" height="1" style="border:none;"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2021/01/20 より、スパトレというオンライン英会話を受け始めました。&lt;/p&gt;
&lt;p&gt;調べた限りで、毎日レッスンが可能なプランがあるオンライン英会話のサービスの中で最安値（税抜き月額¥2,980）。上位プランとして無制限のプランもあり、+2,000円ほどの料金設定にな
      
    
    </summary>
    
    
    
      <category term="英会話" scheme="https://asobitagari.github.io/tags/%E8%8B%B1%E4%BC%9A%E8%A9%B1/"/>
    
      <category term="オンラインレッスン" scheme="https://asobitagari.github.io/tags/%E3%82%AA%E3%83%B3%E3%83%A9%E3%82%A4%E3%83%B3%E3%83%AC%E3%83%83%E3%82%B9%E3%83%B3/"/>
    
      <category term="オンライン英会話" scheme="https://asobitagari.github.io/tags/%E3%82%AA%E3%83%B3%E3%83%A9%E3%82%A4%E3%83%B3%E8%8B%B1%E4%BC%9A%E8%A9%B1/"/>
    
  </entry>
  
  <entry>
    <title>技術書典9を終えて、技術書典10に向けて</title>
    <link href="https://asobitagari.github.io/2020/12/09/after-gijutsushoten-9/"/>
    <id>https://asobitagari.github.io/2020/12/09/after-gijutsushoten-9/</id>
    <published>2020-12-09T02:42:55.000Z</published>
    <updated>2020-12-09T07:00:51.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="サークルの紹介"><a href="#サークルの紹介" class="headerlink" title="サークルの紹介"></a>サークルの紹介</h2><p>技術書典<br><a href="https://techbookfest.org/organization/5754486291169280">https://techbookfest.org/organization/5754486291169280</a></p><p>Booth<br><a href="https://asobitagari.booth.pm/">https://asobitagari.booth.pm/</a></p><h2 id="技術書典9で頒布したもの"><a href="#技術書典9で頒布したもの" class="headerlink" title="技術書典9で頒布したもの"></a>技術書典9で頒布したもの</h2><h3 id="Angular-Panic"><a href="#Angular-Panic" class="headerlink" title="Angular Panic!"></a>Angular Panic!</h3><p>Angular入門本。<br>緩いストーリー仕立てで話が展開され、簡単なアプリケーションの開発までができるようになるまでを解説。</p><h3 id="Re-ゼロから始めるSlack-Hubot開発"><a href="#Re-ゼロから始めるSlack-Hubot開発" class="headerlink" title="Re:ゼロから始めるSlack Hubot開発"></a>Re:ゼロから始めるSlack Hubot開発</h3><p>Hubot本<br>初めてHubotを作る方向けの解説と、筆者が実際に職場のHubotへ実装した、機能の実装例を紹介。<br>著者はサークルメンバーの”PG marbo”</p><h2 id="技術書典10"><a href="#技術書典10" class="headerlink" title="技術書典10"></a>技術書典10</h2><p>技術書典10に向けて、新たにGOでAPIサーバを作るまでの本を書こうと思っています。もともと「Angular Panic!」は中止になった技術書典8に物理本として頒布しようと考えていたものをオンライン開催となった技術書典9で、電子書籍のみで頒布を行いました。この経験と、このイベントで買った複数の電子書籍と、ほかのメディア（Kindle, honto, BookLive!）などで買った電子書籍を呼んできた経験から、次の技術書典10もオンライン開催となることを意識して電子書籍としてもっとあるべき姿があるのではないかと感じるようになりました。<br>その電子書籍として、電子書籍の技術書として向かうべき道の模索をかねて次の書籍は出版したいと考えています。<br>お楽しみしていただけると幸いです。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;サークルの紹介&quot;&gt;&lt;a href=&quot;#サークルの紹介&quot; class=&quot;headerlink&quot; title=&quot;サークルの紹介&quot;&gt;&lt;/a&gt;サークルの紹介&lt;/h2&gt;&lt;p&gt;技術書典&lt;br&gt;&lt;a href=&quot;https://techbookfest.org/organiza
      
    
    </summary>
    
    
    
      <category term="技術書典" scheme="https://asobitagari.github.io/tags/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B8/"/>
    
      <category term="技術書典9" scheme="https://asobitagari.github.io/tags/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B89/"/>
    
      <category term="技術書典10" scheme="https://asobitagari.github.io/tags/%E6%8A%80%E8%A1%93%E6%9B%B8%E5%85%B810/"/>
    
  </entry>
  
  <entry>
    <title>負荷テストツール</title>
    <link href="https://asobitagari.github.io/2019/11/18/load-test/"/>
    <id>https://asobitagari.github.io/2019/11/18/load-test/</id>
    <published>2019-11-18T01:32:08.000Z</published>
    <updated>2020-12-09T02:48:00.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="負荷テストを行うためのツール"><a href="#負荷テストを行うためのツール" class="headerlink" title="負荷テストを行うためのツール"></a>負荷テストを行うためのツール</h2><p>いままでJMeterか、簡単に行うならApach Benchぐらいしか選択肢がなかった負荷テストツールですが、最近いくつか新しいツールを教えてもらったので、忘れないようにメモ。<br>こういう面にもアンテナを伸ばしていかないと、エンジニアとして後れを取ってしまうなぁと感じる今日この頃。そのうち、ここに焦点を当てた記事も書いていきたい。</p><h3 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h3><p>負荷テストといったらこれ。といった印象。というか、最近までこれ以外の方法をろくに知らなかった（apach benchをのぞく）。<br>macで作ったシナリオをubuntuに持って行ったとき、バージョンが合わずに動かなくて苦労したことがある。GUIが使える環境かどうかでJMeterのバージョンも変わる。その時は結局ubuntu側に諸々入れてmacのバージョンに合わせた。そんなubuntuのインスタンスを各リージョンに立てて、システムにアクセスさせるテストを行ったことがある（AWS）。</p><p><a href="https://jmeter.apache.org/">https://jmeter.apache.org/</a></p><h3 id="Vegeta"><a href="#Vegeta" class="headerlink" title="Vegeta"></a>Vegeta</h3><p>最近知った負荷テストツール。Golang製であるのが売りだろうか。つまりJavaじゃない。</p><p><a href="https://github.com/tsenart/vegeta">https://github.com/tsenart/vegeta</a></p><h3 id="Gatling"><a href="#Gatling" class="headerlink" title="Gatling"></a>Gatling</h3><p>軽量でスケールアウトし、スクリプト（Scala）でシナリオ（テスト）をつくれてxmlがいらないやつ。でもJDK8以上が必要。</p><p><a href="https://gatling.io/">https://gatling.io/</a></p><h3 id="Tsung"><a href="#Tsung" class="headerlink" title="Tsung"></a>Tsung</h3><p>動作が軽い。付属ツールでHTMLでのレポートを出力可能。スレッド数での負荷調整ではなく、秒間〇セッションといった風な調整方法なので、そのまま秒間〇アクセスといった目標値を設定しやすい。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;負荷テストを行うためのツール&quot;&gt;&lt;a href=&quot;#負荷テストを行うためのツール&quot; class=&quot;headerlink&quot; title=&quot;負荷テストを行うためのツール&quot;&gt;&lt;/a&gt;負荷テストを行うためのツール&lt;/h2&gt;&lt;p&gt;いままでJMeterか、簡単に行うならApa
      
    
    </summary>
    
    
    
      <category term="load test" scheme="https://asobitagari.github.io/tags/load-test/"/>
    
      <category term="development" scheme="https://asobitagari.github.io/tags/development/"/>
    
      <category term="JMeter" scheme="https://asobitagari.github.io/tags/JMeter/"/>
    
      <category term="Vegeta" scheme="https://asobitagari.github.io/tags/Vegeta/"/>
    
  </entry>
  
  <entry>
    <title>dockerコンテナ</title>
    <link href="https://asobitagari.github.io/2019/11/10/docker-container/"/>
    <id>https://asobitagari.github.io/2019/11/10/docker-container/</id>
    <published>2019-11-10T04:41:34.000Z</published>
    <updated>2019-11-10T06:00:48.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="dockerコンテナ"><a href="#dockerコンテナ" class="headerlink" title="dockerコンテナ"></a>dockerコンテナ</h2><h3 id="状態-ライフサイクル"><a href="#状態-ライフサイクル" class="headerlink" title="状態/ライフサイクル"></a>状態/ライフサイクル</h3><p>dockerコンテナはイメージと違い、状態を持っている。状態は、<code>実行中・停止・破棄</code>がある。</p><h4 id="実行中"><a href="#実行中" class="headerlink" title="実行中"></a>実行中</h4><p><code>docker container run</code>で起動させると実行中となり、Dockerfileに記述された<code>CMD</code>のコマンドを実行し終わるまで自動中となる。<br>よって、デーモン/サーバー系のコマンドであれば任意に停止、もしくは異常終了するまでそのコンテナは実行中となるが、そうでない場合(lsコマンドなど即座に終了するもの)は、そのコマンドを終えるまでが実行中となる。<br>CMDの実行が完了すると、コンテナは<code>停止</code>の状態へ移行する。</p><h4 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h4><p><code>実行中</code>であったコンテナが<code>停止</code>した状態。停止した状態なので、再利用が可能。停止した時点の情報を持っているので、ディスクなどの容量は使用している。</p><h4 id="破棄"><a href="#破棄" class="headerlink" title="破棄"></a>破棄</h4><p><code>停止</code>状態のコンテナは明示的に<code>破棄</code>をしない限りディスクに残り続ける。頻繁に実行-&gt;停止を繰り返す運用の場合には、停止されたコンテナがたまるため（再利用されない限りは実行のたびに新たなコンテナが立ち上がる）、ディスク容量を圧迫していくことになる。完全に不要となったコンテナは削除を行った方がいい。<br>ただし、一度破棄したコンテナを再び利用することはできないため、退避しなければいけない情報がないか確認してから行うこと。</p><h3 id="コンテナ操作"><a href="#コンテナ操作" class="headerlink" title="コンテナ操作"></a>コンテナ操作</h3><p>dockerのコンテナは、dockerイメージから作成を行う。作成が完了されると実行状態となる。<br>イメージの指定方法は、イメージ名かイメージに割り振られたIDを指定することができる。</p><p>イメージ名での作成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run [options] イメージ名[:タグ] [コマンド] [コマンド引数...]</span><br></pre></td></tr></table></figure><p>イメージIDでの作成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run [options] イメージID [コマンド] [コマンド引数...]</span><br></pre></td></tr></table></figure><h4 id="名前付きコンテナ"><a href="#名前付きコンテナ" class="headerlink" title="名前付きコンテナ"></a>名前付きコンテナ</h4><p>イメージからコンテナを作成した場合、コンテナの名前は自動で割り振られる。</p><p><code>docker container ls [--all]</code>を行った際に<code>NAMES</code>列に記載されているのが自動で割り振られたコンテナの名前。<br>オプション<code>--all</code>を指定することで、停止中のコンテナについている名前も確認することができる。この名前を利用して、再利用することも可能。<br>また、コンテナ起動時にオプションで名前を付けることもできる。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run --name [任意のコンテナ名] [イメージ名]:[タグ]</span><br></pre></td></tr></table></figure><p>イメージの指定の仕方はコンテナの起動の項目を参照。<br>ホスト側のポートは省略することができ、省略時は自動で空いているエフェメラルポートが割り当てられる。<br>割り当てられたポートは<code>docker container ls</code>で表示される<code>ports</code>の項目で確認できる。</p><h2 id="実行中コンテナの標準出力を取得"><a href="#実行中コンテナの標準出力を取得" class="headerlink" title="実行中コンテナの標準出力を取得"></a>実行中コンテナの標準出力を取得</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container logs [-f] コンテナID/コンテナ名</span><br></pre></td></tr></table></figure><p><code>-f</code>をつけると<code>tail -f</code>のように、指定したコンテナの標準出力を取得し続ける。</p><h2 id="実行中コンテナでコマンドの実行"><a href="#実行中コンテナでコマンドの実行" class="headerlink" title="実行中コンテナでコマンドの実行"></a>実行中コンテナでコマンドの実行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container exec [options] コンテナID/コンテナ名 コンテナで実行したいコマンド</span><br></pre></td></tr></table></figure><p><code>-i -i / -it sh</code> で実行中のコンテナにシェルで操作ができる。</p><h2 id="コンテナとのファイルコピー"><a href="#コンテナとのファイルコピー" class="headerlink" title="コンテナとのファイルコピー"></a>コンテナとのファイルコピー</h2><p>コンテナからホスト</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker contaner cp [options] コンテナID/コンテナ名:コピー元パス コピー先ホストパス</span><br></pre></td></tr></table></figure><p>ホストからコンテナ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container cp [option] コピー元ホストパス コンテナID/コンテナ名:コピー先パス</span><br></pre></td></tr></table></figure><h2 id="コンテナの破棄"><a href="#コンテナの破棄" class="headerlink" title="コンテナの破棄"></a>コンテナの破棄</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune [options]</span><br></pre></td></tr></table></figure><p>停止中のコンテナを一括削除できる。</p><h3 id="イメージの削除"><a href="#イメージの削除" class="headerlink" title="イメージの削除"></a>イメージの削除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune [options]</span><br></pre></td></tr></table></figure><p>不要そうなdockerイメージをdockerが判断して削除してくれる。</p><h3 id="いろいろ削除"><a href="#いろいろ削除" class="headerlink" title="いろいろ削除"></a>いろいろ削除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system prune</span><br></pre></td></tr></table></figure><p>停止中のコンテナ、ネットワーク、イメージ、ビルドキャッシュといった内容の削除をしてくれる。</p><h2 id="コンテナの統計情報を取得"><a href="#コンテナの統計情報を取得" class="headerlink" title="コンテナの統計情報を取得"></a>コンテナの統計情報を取得</h2><pre><code>docker container stats [options] コンテナ名/コンテナID[ ...(複数指定可)]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;dockerコンテナ&quot;&gt;&lt;a href=&quot;#dockerコンテナ&quot; class=&quot;headerlink&quot; title=&quot;dockerコンテナ&quot;&gt;&lt;/a&gt;dockerコンテナ&lt;/h2&gt;&lt;h3 id=&quot;状態-ライフサイクル&quot;&gt;&lt;a href=&quot;#状態-ライフサイクル&quot;
      
    
    </summary>
    
    
    
      <category term="development" scheme="https://asobitagari.github.io/tags/development/"/>
    
      <category term="docker" scheme="https://asobitagari.github.io/tags/docker/"/>
    
      <category term="container" scheme="https://asobitagari.github.io/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>Docker メモ</title>
    <link href="https://asobitagari.github.io/2019/11/05/docker-memo/"/>
    <id>https://asobitagari.github.io/2019/11/05/docker-memo/</id>
    <published>2019-11-05T09:31:19.000Z</published>
    <updated>2019-11-10T05:53:29.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="インストラクション"><a href="#インストラクション" class="headerlink" title="インストラクション"></a>インストラクション</h3><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>　FROMは作成するDockerイメージのベースとなるイメージを指定でいる。<br>　FROMで指定できるDockerイメージはDocker Hubに公開されているものから指定できる。</p><h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>　イメージ作者の情報などを記述。</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>　Dockerコンテナ内で使える環境変数を設定できる。</p><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>　ビルド時に指定する引数から値を受け取ることができる。<br>　Dockerfile内で指定したARGの引数と、ビルド時に指定する引数はそろえる必要がある。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#コマンド：sampleargがそろえるべき名前</span><br><span class="line">&gt; docker image build --build-arg samplearg=okok -t example/dockerimage .</span><br><span class="line"></span><br><span class="line">#Dockerfileでは以下のように名前を指定して二行目のように値を取り出すことができる。</span><br><span class="line">ARG samplearg</span><br><span class="line">ENV BUILD_ARG=$&#123;samplearg&#125;</span><br></pre></td></tr></table></figure><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>　RUNはDockerイメージビルド時に、Dockerコンテナ内で実行するコマンドを定義する。<br>　RUNの引数には実行したいコマンドをそのまま記述する。</p><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>　COPYはDockerを動作させているホストマシン上のファイルやディレクトリをDockerコンテナ内にコピーするためのインストラクション。</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>　CMDはDockerコンテナとして実行する際に、コンテナ内で実行するプロセスを指定する。<br>　RUNはイメージをビルドするために使い、CMDはコンテナ起動時に一度実行される。</p><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>　ENTRYPOINTにはコマンドを記述する。CMDはENTRYPOINTへの引数となる。–entrypointでrun時に指定することで上書きできる。</p><h2 id="ビルド"><a href="#ビルド" class="headerlink" title="ビルド"></a>ビルド</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t イメージ[:タグ名] Dockerfileまでのパス</span><br></pre></td></tr></table></figure><p>タグ名は省略するとlatestとなる。</p><h2 id="イメージからコンテナの実行"><a href="#イメージからコンテナの実行" class="headerlink" title="イメージからコンテナの実行"></a>イメージからコンテナの実行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] run [-d] [-i] [-t] [-rm] [-v ホスト側ディレクトリ:コンテナ側ディレクトリ] イメージ名[/追加のパス]:タグ名</span><br></pre></td></tr></table></figure><p><code>-d</code>オプションをつけないとフォアグランドで実行されてしまう。-dをつけて起動した場合はコンテナIDが標準出力に出力される。<br>containerは省略可能だが、最近の風潮ではタイプが長くなるがつけて記述するほうが好まれるらしい。</p><p><code>-i</code>起動後にコンテナの標準入力との結びつきを維持する。</p><p><code>-t</code>疑似端末を有効にする。大抵の場合<code>-i</code>と同時に用いられ、同時指定の<code>-it</code>が省略形として存在する。コンテナ起動後に、疑似端末が有効となり標準入力からコマンドを実行できるようになる。</p><p><code>-rm</code>コンテナの終了時にコンテナを破棄する。</p><p><code>-v</code>ホストとコンテナ間でディレクトリやファイルの共有を行う。</p><h3 id="そのほかオプション"><a href="#そのほかオプション" class="headerlink" title="そのほかオプション"></a>そのほかオプション</h3><p><code>-f</code> Dockerfileのファイル名を指定できる。省略時は<code>Dockerfile</code></p><p><code>--pull=true</code> ビルド時に<code>FROM</code>で指定したイメージをレジストリからダウンロードを必ず行う。省略時は、すでにダウンロード済みであれば、ホスト内のキャッシュからビルドを行い、存在しない場合はレジストリからダウンロードする。</p><h2 id="起動中のコンテナの確認"><a href="#起動中のコンテナの確認" class="headerlink" title="起動中のコンテナの確認"></a>起動中のコンテナの確認</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>上記二つはどちらも同じ動作。<br>表示項目のフィルタリングもできる。コンテナIDだけ抽出する場合は以下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls --filter &quot;ancestor=[イメージ名]&quot; [-q]</span><br></pre></td></tr></table></figure><p>-q でコンテナIDのみの抽出</p><h2 id="起動中のコンテナの停止"><a href="#起動中のコンテナの停止" class="headerlink" title="起動中のコンテナの停止"></a>起動中のコンテナの停止</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop コンテナID/コンテナ名</span><br></pre></td></tr></table></figure><p><code>docker container ls</code>と組み合わせることができる。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop $(docker container ls --filter &quot;ancestor=[イメージ名&quot; -q])</span><br></pre></td></tr></table></figure><h2 id="停止中のコンテナの再起動"><a href="#停止中のコンテナの再起動" class="headerlink" title="停止中のコンテナの再起動"></a>停止中のコンテナの再起動</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container restart コンテナID/コンテナ名</span><br></pre></td></tr></table></figure><h2 id="停止中のコンテナの破棄"><a href="#停止中のコンテナの破棄" class="headerlink" title="停止中のコンテナの破棄"></a>停止中のコンテナの破棄</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container rm [-f] コンテナID/コンテナ名</span><br></pre></td></tr></table></figure><p><code>-f</code>オプションで実行中のコンテナの削除も可能。</p><h2 id="dockerイメージの検索"><a href="#dockerイメージの検索" class="headerlink" title="dockerイメージの検索"></a>dockerイメージの検索</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [options] 検索キーワード</span><br></pre></td></tr></table></figure><p><code>-f, --filter filter</code> 出力をフィルターする。<br><code>--format 文字列</code> 出力をフォーマットする。<br><code>--limit 数値</code> 表示件数を指定の数値に制限する。<br><code>--no-trunc</code> 出力を省略せずに表示する。</p><h2 id="dockerイメージの取得"><a href="#dockerイメージの取得" class="headerlink" title="dockerイメージの取得"></a>dockerイメージの取得</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull [options] リポジトリ名[:タグ名]</span><br></pre></td></tr></table></figure><p>例によってタグ名を省略した場合は<code>latest</code>が指定される。</p><h2 id="ホスト内のイメージの一覧を取得"><a href="#ホスト内のイメージの一覧を取得" class="headerlink" title="ホスト内のイメージの一覧を取得"></a>ホスト内のイメージの一覧を取得</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls [options] [リポジトリ[:タグ名]]</span><br></pre></td></tr></table></figure><p>ダウンロード済み、ビルド済みのイメージの一覧を表示する。</p><h2 id="dockerイメージのタグ付け"><a href="#dockerイメージのタグ付け" class="headerlink" title="dockerイメージのタグ付け"></a>dockerイメージのタグ付け</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image tag 元のイメージ名[:タグ名] 新しいイメージ名[:タグ名]</span><br></pre></td></tr></table></figure><p>タグ名を省略時は<code>latest</code></p><h2 id="docker-Hub-へログイン"><a href="#docker-Hub-へログイン" class="headerlink" title="docker Hub へログイン"></a>docker Hub へログイン</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login [-u id] [-p パスワード]</span><br></pre></td></tr></table></figure><p>オプションを省略した場合は対話式に進めることができる。ID&amp;PASSを入力して認証する。</p><h2 id="docker-hub-イメージの登録"><a href="#docker-hub-イメージの登録" class="headerlink" title="docker hub イメージの登録"></a>docker hub イメージの登録</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image push [options] リポジトリ名[:タグ名]</span><br></pre></td></tr></table></figure><p>ログイン済みであれば、自分のリポジトリにイメージを登録することができる。</p><h2 id="ポートフォワーディング"><a href="#ポートフォワーディング" class="headerlink" title="ポートフォワーディング"></a>ポートフォワーディング</h2><p>ポートフォワーディングは<code>docker container run</code>の起動コマンド時に<code>-p</code>オプションで指定できる。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -d -p [ホストポート]:コンテナポート イメージの指定</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dockerfile&quot;&gt;&lt;a href=&quot;#Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile&quot;&gt;&lt;/a&gt;Dockerfile&lt;/h2&gt;&lt;h3 id=&quot;インストラクション&quot;&gt;&lt;a href=&quot;#インストラクション&quot; c
      
    
    </summary>
    
    
    
      <category term="development" scheme="https://asobitagari.github.io/tags/development/"/>
    
      <category term="docker" scheme="https://asobitagari.github.io/tags/docker/"/>
    
      <category term="container" scheme="https://asobitagari.github.io/tags/container/"/>
    
  </entry>
  
</feed>
