{"meta":{"title":"遊びたがりブログ","subtitle":"","description":"","author":"ざきさん","url":"https://asobitagari.github.io","root":"/"},"pages":[],"posts":[{"title":"負荷テストツール","slug":"load-test","date":"2019-11-18T01:32:08.000Z","updated":"2019-11-18T09:19:30.968Z","comments":true,"path":"2019/11/18/load-test/","link":"","permalink":"https://asobitagari.github.io/2019/11/18/load-test/","excerpt":"","text":"負荷テストを行うためのツールいままでJMeterか、簡単に行うならApach Benchぐらいしか選択肢がなかった負荷テストツールですが、最近いくつか新しいツールを教えてもらったので、忘れないようにメモ。こういう面にもアンテナを伸ばしていかないと、エンジニアとして後れを取ってしまうなぁと感じる今日この頃。そのうち、ここに焦点を当てた記事も書いていきたい。 JMeter負荷テストといったらこれ。といった印象。というか、最近までこれ以外の方法をろくに知らなかった（apach benchをのぞく）。macで作ったシナリオをubuntuに持って行ったとき、バージョンが合わずに動かなくて苦労したことがある。GUIが使える環境かどうかでJMeterのバージョンも変わる。その時は結局ubuntu側に諸々入れてmacのバージョンに合わせた。そんなubuntuのインスタンスを各リージョンに立てて、システムにアクセスさせるテストを行ったことがある（AWS）。 https://jmeter.apache.org/ Vegeta最近知った負荷テストツール。Golang製であるのが売りだろうか。つまりJavaじゃない。 https://github.com/tsenart/vegeta Gatling軽量でスケールアウトし、スクリプト（Scala）でシナリオ（テスト）をつくれてxmlがいらないやつ。でもJDK8以上が必要。 https://gatling.io/ Tsung動作が軽い。付属ツールでHTMLでのレポートを出力可能。スレッド数での負荷調整ではなく、秒間〇セッションといった風な調整方法なので、そのまま秒間〇アクセスといった目標値を設定しやすい。","categories":[],"tags":[{"name":"development","slug":"development","permalink":"https://asobitagari.github.io/tags/development/"},{"name":"load test","slug":"load-test","permalink":"https://asobitagari.github.io/tags/load-test/"},{"name":"JMeter","slug":"JMeter","permalink":"https://asobitagari.github.io/tags/JMeter/"},{"name":"Vegeta","slug":"Vegeta","permalink":"https://asobitagari.github.io/tags/Vegeta/"}]},{"title":"dockerコンテナ","slug":"docker-container","date":"2019-11-10T04:41:34.000Z","updated":"2019-11-10T06:00:48.238Z","comments":true,"path":"2019/11/10/docker-container/","link":"","permalink":"https://asobitagari.github.io/2019/11/10/docker-container/","excerpt":"","text":"dockerコンテナ状態/ライフサイクルdockerコンテナはイメージと違い、状態を持っている。状態は、実行中・停止・破棄がある。 実行中docker container runで起動させると実行中となり、Dockerfileに記述されたCMDのコマンドを実行し終わるまで自動中となる。よって、デーモン/サーバー系のコマンドであれば任意に停止、もしくは異常終了するまでそのコンテナは実行中となるが、そうでない場合(lsコマンドなど即座に終了するもの)は、そのコマンドを終えるまでが実行中となる。CMDの実行が完了すると、コンテナは停止の状態へ移行する。 停止実行中であったコンテナが停止した状態。停止した状態なので、再利用が可能。停止した時点の情報を持っているので、ディスクなどの容量は使用している。 破棄停止状態のコンテナは明示的に破棄をしない限りディスクに残り続ける。頻繁に実行-&gt;停止を繰り返す運用の場合には、停止されたコンテナがたまるため（再利用されない限りは実行のたびに新たなコンテナが立ち上がる）、ディスク容量を圧迫していくことになる。完全に不要となったコンテナは削除を行った方がいい。ただし、一度破棄したコンテナを再び利用することはできないため、退避しなければいけない情報がないか確認してから行うこと。 コンテナ操作dockerのコンテナは、dockerイメージから作成を行う。作成が完了されると実行状態となる。イメージの指定方法は、イメージ名かイメージに割り振られたIDを指定することができる。 イメージ名での作成 1docker container run [options] イメージ名[:タグ] [コマンド] [コマンド引数...] イメージIDでの作成 1docker container run [options] イメージID [コマンド] [コマンド引数...] 名前付きコンテナイメージからコンテナを作成した場合、コンテナの名前は自動で割り振られる。 docker container ls [--all]を行った際にNAMES列に記載されているのが自動で割り振られたコンテナの名前。オプション--allを指定することで、停止中のコンテナについている名前も確認することができる。この名前を利用して、再利用することも可能。また、コンテナ起動時にオプションで名前を付けることもできる。 1docker container run --name [任意のコンテナ名] [イメージ名]:[タグ] イメージの指定の仕方はコンテナの起動の項目を参照。ホスト側のポートは省略することができ、省略時は自動で空いているエフェメラルポートが割り当てられる。割り当てられたポートはdocker container lsで表示されるportsの項目で確認できる。 実行中コンテナの標準出力を取得1docker container logs [-f] コンテナID/コンテナ名 -fをつけるとtail -fのように、指定したコンテナの標準出力を取得し続ける。 実行中コンテナでコマンドの実行1docker container exec [options] コンテナID/コンテナ名 コンテナで実行したいコマンド -i -i / -it sh で実行中のコンテナにシェルで操作ができる。 コンテナとのファイルコピーコンテナからホスト 1docker contaner cp [options] コンテナID/コンテナ名:コピー元パス コピー先ホストパス ホストからコンテナ 1docker container cp [option] コピー元ホストパス コンテナID/コンテナ名:コピー先パス コンテナの破棄1docker container prune [options] 停止中のコンテナを一括削除できる。 イメージの削除1docker image prune [options] 不要そうなdockerイメージをdockerが判断して削除してくれる。 いろいろ削除1docker system prune 停止中のコンテナ、ネットワーク、イメージ、ビルドキャッシュといった内容の削除をしてくれる。 コンテナの統計情報を取得docker container stats [options] コンテナ名/コンテナID[ ...(複数指定可)]","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://asobitagari.github.io/tags/docker/"},{"name":"container","slug":"container","permalink":"https://asobitagari.github.io/tags/container/"},{"name":"development","slug":"development","permalink":"https://asobitagari.github.io/tags/development/"}]},{"title":"Docker メモ","slug":"docker-memo","date":"2019-11-05T09:31:19.000Z","updated":"2019-11-10T05:53:29.356Z","comments":true,"path":"2019/11/05/docker-memo/","link":"","permalink":"https://asobitagari.github.io/2019/11/05/docker-memo/","excerpt":"","text":"DockerfileインストラクションFROM FROMは作成するDockerイメージのベースとなるイメージを指定でいる。 FROMで指定できるDockerイメージはDocker Hubに公開されているものから指定できる。 LABEL イメージ作者の情報などを記述。 ENV Dockerコンテナ内で使える環境変数を設定できる。 ARG ビルド時に指定する引数から値を受け取ることができる。 Dockerfile内で指定したARGの引数と、ビルド時に指定する引数はそろえる必要がある。 123456#コマンド：sampleargがそろえるべき名前&gt; docker image build --build-arg samplearg=okok -t example/dockerimage .#Dockerfileでは以下のように名前を指定して二行目のように値を取り出すことができる。ARG sampleargENV BUILD_ARG=$&#123;samplearg&#125; RUN RUNはDockerイメージビルド時に、Dockerコンテナ内で実行するコマンドを定義する。 RUNの引数には実行したいコマンドをそのまま記述する。 COPY COPYはDockerを動作させているホストマシン上のファイルやディレクトリをDockerコンテナ内にコピーするためのインストラクション。 CMD CMDはDockerコンテナとして実行する際に、コンテナ内で実行するプロセスを指定する。 RUNはイメージをビルドするために使い、CMDはコンテナ起動時に一度実行される。 ENTRYPOINT ENTRYPOINTにはコマンドを記述する。CMDはENTRYPOINTへの引数となる。–entrypointでrun時に指定することで上書きできる。 ビルド1docker image build -t イメージ[:タグ名] Dockerfileまでのパス タグ名は省略するとlatestとなる。 イメージからコンテナの実行1docker [container] run [-d] [-i] [-t] [-rm] [-v ホスト側ディレクトリ:コンテナ側ディレクトリ] イメージ名[/追加のパス]:タグ名 -dオプションをつけないとフォアグランドで実行されてしまう。-dをつけて起動した場合はコンテナIDが標準出力に出力される。containerは省略可能だが、最近の風潮ではタイプが長くなるがつけて記述するほうが好まれるらしい。 -i起動後にコンテナの標準入力との結びつきを維持する。 -t疑似端末を有効にする。大抵の場合-iと同時に用いられ、同時指定の-itが省略形として存在する。コンテナ起動後に、疑似端末が有効となり標準入力からコマンドを実行できるようになる。 -rmコンテナの終了時にコンテナを破棄する。 -vホストとコンテナ間でディレクトリやファイルの共有を行う。 そのほかオプション-f Dockerfileのファイル名を指定できる。省略時はDockerfile --pull=true ビルド時にFROMで指定したイメージをレジストリからダウンロードを必ず行う。省略時は、すでにダウンロード済みであれば、ホスト内のキャッシュからビルドを行い、存在しない場合はレジストリからダウンロードする。 起動中のコンテナの確認12docker container lsdocker ps 上記二つはどちらも同じ動作。表示項目のフィルタリングもできる。コンテナIDだけ抽出する場合は以下。 1docker container ls --filter &quot;ancestor=[イメージ名]&quot; [-q] -q でコンテナIDのみの抽出 起動中のコンテナの停止1docker container stop コンテナID/コンテナ名 docker container lsと組み合わせることができる。 1docker container stop $(docker container ls --filter &quot;ancestor=[イメージ名&quot; -q]) 停止中のコンテナの再起動1docker container restart コンテナID/コンテナ名 停止中のコンテナの破棄1docker container rm [-f] コンテナID/コンテナ名 -fオプションで実行中のコンテナの削除も可能。 dockerイメージの検索1docker search [options] 検索キーワード -f, --filter filter 出力をフィルターする。--format 文字列 出力をフォーマットする。--limit 数値 表示件数を指定の数値に制限する。--no-trunc 出力を省略せずに表示する。 dockerイメージの取得1docker image pull [options] リポジトリ名[:タグ名] 例によってタグ名を省略した場合はlatestが指定される。 ホスト内のイメージの一覧を取得1docker image ls [options] [リポジトリ[:タグ名]] ダウンロード済み、ビルド済みのイメージの一覧を表示する。 dockerイメージのタグ付け1docker image tag 元のイメージ名[:タグ名] 新しいイメージ名[:タグ名] タグ名を省略時はlatest docker Hub へログイン1docker login [-u id] [-p パスワード] オプションを省略した場合は対話式に進めることができる。ID&amp;PASSを入力して認証する。 docker hub イメージの登録1docker image push [options] リポジトリ名[:タグ名] ログイン済みであれば、自分のリポジトリにイメージを登録することができる。 ポートフォワーディングポートフォワーディングはdocker container runの起動コマンド時に-pオプションで指定できる。 1docker container run -d -p [ホストポート]:コンテナポート イメージの指定","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://asobitagari.github.io/tags/docker/"},{"name":"container","slug":"container","permalink":"https://asobitagari.github.io/tags/container/"},{"name":"development","slug":"development","permalink":"https://asobitagari.github.io/tags/development/"}]}]}